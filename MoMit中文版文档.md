# MOSIUTER,看见世界,自由又私密

## 简介

> MOSIUTER是一个现代化加密协议.
>
> 这个协议采用多模式混淆+加密来传输你的数据,确保即使别人拿到你的数据也不知道你的真实意图,而且伪装到就像正常互联网请求一样.
>
> 传输协议和加密特征都使用一个IV来规定,且这个IV每间隔几分钟都会变换,来保证数据包无法被DPI判断到规则.
>
> 首先,你的数据会先进行数据包优化,然后使用snowflake或者obfs4之类的加密先去掉特征,再配合TLS进行加密,使数据包看起来就像正常的互联网加密数据.

## 快速上手
>下载mosiuterclient和mosiuterserver
>
>将mosiuterserver放到服务器上 然后启动
>
>此时他会生成两个密钥文件 你只需要打开.pem结尾的那个文件 这个密钥文件是用来加密传输前几个重要数据包的密钥
>
>然后你需要按照前2步的配置,配置好两台服务器(最少两台,用来分散DPI注意的,最多10台,当然,越多越好)
>
>然后在本地mosiuterclient目录下 编辑ip.txt文件 删除文件内容 然后写入服务器的IP地址和端口号
>
>然后启动mosiuterclient 他会自动随机然后连接服务器 然后开始数据传输 你需要先等待个几秒 让前几个数据包传输完毕
>
>然后你需要等待客户端的提示 他会输出你的IP:端口 最后将代理服务器设置为它输出的 然后直接浏览器访问网站 即可开始加密你的上网流量

## 如何编译

> mosiuter分为客户端(mosiuterclient)和服务端(mosiuterserver),你可以在根目录找到这两个文件夹
>
> 第0步 需要先CD到根文件夹以及Go语言环境 版本1.23.4
>
> ### 首先说用Go build编译 
>
> 客户端:`cd ./mosiuterclient` (先回车) 然后 `go build` 
>
> 服务端:`cd ./mosiuterserver` (先回车) 然后 `go build`
>
> ### 然后说用MakeFile编译
>
> 客户端:make client
>
> 服务端:make server
>
> 清理编译的二进制文件:make debuild
>
> 运行目录的build-all脚本

## 传输协议

> 代码表示IV1是几 就用什么协议传输

| 代码 | 协议           |
| ---- | -------------- |
| 1    | TCP RAW        |
| 2    | UDP 默认为QUIC |
| 3    | TLS            |
| 4    | HTTPS          |
| 5    | DoT            |
| 6    | DoH            |
| 7    | mKCP           |
| 8    | gRCP           |

## 伪装协议

> 代码IV2是几 就是什么伪装特征
>
> 而且还会添加一定的随机值 在数据包开始传输前就商量好在什么位置(可能会在一个数据包内多地方插入多个随机值)
>
> 更气死防火墙的是 每间隔一个随机值(最小为1 最大为20的整数) 这个代码还会随机生成一个新的 使代理服务器也伪装成反代 客户端伪装成利用这个反代上网 正常使用
>
> 还有TTL值伪装 让代理服务器看起来更像一个反代服务器
>
> 还有代理服务器IP自动轮换 每隔几分钟换一个代理服务器IP 气死DPI 而且还支持IPv6 更气死DPI
>
> 更气死DPI的是 这东西还会发送几个真真假假的数据包 他会真的创建一个访问网站的请求 但是到达代理服务器后就会被删除
>
> 如果某个IP对代理服务器重放数据包 他还会真的返回一个合法的页面(或者合法网站DNS查询结果)给这个IP 而且为了避免露馅 这个IP还会被记录 每一次重放都会返回一样的数据

| 代码 | 伪装特征           | 伪装行为                                                     |
| ---- | ------------------ | ------------------------------------------------------------ |
| 9    | 看视频网站         | 模拟CDN行为 将流量分成多个小片段 随机分布在不同IP上          |
| 10   | 听音乐网站         | 模拟缓冲与暂停 间歇性传输流量，而非持续传输                  |
| 11   | 下载大文件         | 模拟断点续传 间隔一段时间重新请求文件的不同部分              |
| 12   | 登录cloudflare网站 | 小数据包 间隔时间稍长 模拟登录一个网站                       |
| 13   | 玩网络游戏         | 高频小数据包 模拟UDP流量 结合Ping值随机化(但是也有个限度 最大500ms 最小100ms 而且波动稍小) |
| 14   | 视频通话           | 模拟WebRTC或Zoom等视频会议协议                               |
| 15   | 随机数据           | 用OBFS4+Shandowsocks先行伪装 然后插入几个无用数据            |

## 数据包加速

> MOSIUTER采用多种先进的数据包体积缩小模式 用来保证数据包体积更小 传输的数据更多
>
> 1.前导码删除
>
> 2.帧间隙删除
>
> 3.尽可能尝试帧分片
>
> 4.如果协议基于TCP 还会开启BBR
>
> 5.如果协议基于UDP 还会开启UOT
>
> 6.启用头部压缩
>
> 7.启用服务端(到代理服务器)Gzip压缩和Brotli压缩
>
> 8.如果随机到了https 还会启用HTTP/3
>
> 9.合并相似数据
>
> 10.IPv4/v6自动选择最优
>
> 11.启用视频或图片压缩
>
> 还有更多

## 运行流程

> 首先客户端需要拿到服务器密钥和一个服务器信任列表
>
> 信任列表一次最多10条最少2条 可以是IPv4\IPv6单地址 优先推荐IPv4服务器搭建 毕竟相对于IPV6 这东西传输的话更稳定



> 1.通信代理服务器 与其建立WS连接 如果有中间人篡改则立即切断网络(kill swithy)
>
> 2.然后开始第二个数据包交换:把随机数据IV1通报服务器
>
> 3.服务器拿到这个数值之后 向客户端发送一个已收到数据包 
>
> 4.开始商议随机数据位置 (IV3) 数字是几就添加几个随机包 数值为最大35最小15的整数
>
> 5.客户端开始随机数据 并将配置的加密密钥用作随机数据位置通报数据包的传输加密
>
> 6.服务端确认一切安好后 客户端开始随机IV2
>
> 7.IV2随机完毕后 向服务器加密数据后通报IV2是几
>
> 8.在客户端收到数据包后切断WS连接 由服务器1通告使用的加密方式给下一个服务器(加密通告)
>
> 9.获取浏览器数据 开始数据包优化工作
>
> 10.(当到达时间时) 客户端结束这台服务器的连接 开启一个新的连接 对着这个新地址开始连接
>
> 11.当随机的时间到期后就会切断跟这台服务器的连接 继续开启下一台服务器 如此循环
